////////////////////////////////////////////////////////////////////////////////
// HTTP-сервисы: процедуры и функции работы HTTP-сервисов
//  
////////////////////////////////////////////////////////////////////////////////

#Область ПрограммныйИнтерфейс

#Область ОтветНаЗапрос

// Возвращает HTTPСервисОтвет, подготовленный, исходя из формата переданных параметров
//
// Параметры:
//  КодСостояния - Число - Код состояния HTTP
//		Например, 200 для OK или 400 для Bad Request
//  ТелоОтвета - Строка, Произвольный - Значение, передаваемое в ответ на запрос
//										Если тип контента "application/json", перед отправкой сериализуется в JSON
//											Если при этом передана строка - сериализуется в структуру, исходя из кода состояния
//											Если код 200 - ключ структуры "result", если иной - "error"
//											Значение должно быть сериализуемым в JSON
//										Если тип контента иной - преобразование не выполняется
//										Если тип контента иной и передана не строка - бросается исключение
//	Файл - Строка, ДвоичныеДанные, Поток, Структура - Файл, отправляемый в теле ответа
//									Путь в файловой системе, адрес во временном хранилище, 
//									двоичные данные файла или структура из СтруктураОписаниеДанных(),
//									Для отправки файлов с диска рекомендуется использовать структуру из СтруктураОписаниеДанныхПоИмениФайла
//	Заголовки - Соответствие - Заголовки, передаваемые в ответе (заменяет автоматические сформированные)
//	ТипКонтента - Строка - Строка, передаваемая в заголовок "Content-Type", 
//						   Используется в том числе для анализа действий с переданным телом
//	Кодировка - Строка - Кодировка, используемая в заголовке "Content-Type", параметр "charset"
//
// Возвращаемое значение:
//  HTTPСервисОтвет - ответ, формируемый HTTP-сервисом  
//
Функция СформироватьHTTPОтвет(КодСостояния, Тело = "", Файл = "", Заголовки = Неопределено, ТипКонтента = "application/json", Кодировка = "utf-8") Экспорт
	
	Если ЭтоАдресВременногоХранилища(Файл) Тогда
		Возврат СформироватьHTTPОтвет(КодСостояния, 
									  Тело, 
									  ПолучитьИзВременногоХранилища(Файл), 
									  Заголовки, 
									  ТипКонтента, 
									  Кодировка);
	КонецЕсли;
	
	Ответ = Новый HTTPСервисОтвет(КодСостояния);
	
	HTTPСервисыСлужебный.УстановитьТелоИЗаголовки(Ответ, Тело, Файл, Заголовки, ТипКонтента, Кодировка);
	
	Возврат Ответ;

КонецФункции

// Возвращает HTTPСервисОтвет об ошибке
//
// Параметры:
//  КодСостояния - Число - Код состояния (ответа), возвращаемый HTTP-сервисом
//  ИмяСобытия - Строка - Имя события журнала регистрации
//  Комментарий	- Строка - Комментарий журнала регистрации
//  Заголовки - Соответствие - Коллекция заголовков, которые должны быть переданы на клиента
// 
// Возвращаемое значение:
//  HTTPСервисОтвет - ответ об ошибке
//
Функция СообщениеОбОшибке(КодСостояния, ИмяСобытия, Комментарий = "", Заголовки = Неопределено, ТекстОшибки = "") Экспорт 
	
	HTTPСервисыСлужебный.ЗаписатьОшибкуВЖурналРегистрации(ИмяСобытия, КодСостояния, Комментарий);
	Возврат СформироватьHTTPОтвет(КодСостояния, ТекстОшибки,, Заголовки, "text/plain");

КонецФункции

Функция ПолучитьЗаголовок(HTTPОбъект, Название) Экспорт
	
	Если НЕ ЗначениеЗаполнено(Название) Тогда
		Возврат Неопределено;
	КонецЕсли;
	
	Заголовки = HTTPОбъект.Заголовки;
	
	Возврат HTTPСервисыСлужебный.СвойствоСоответствия(Заголовки, Название);
	
КонецФункции

#КонецОбласти

#Область ОтправкаЗапросов

Функция ПараметрыЗапроса(Параметры = Неопределено) Экспорт

	ПараметрыЗапроса = Новый Структура;
	ПараметрыЗапроса.Вставить("Соединение");
	ПараметрыЗапроса.Вставить("Прокси");
	ПараметрыЗапроса.Вставить("Таймаут", 30);
	ПараметрыЗапроса.Вставить("ЗащищенноеСоединение");
	ПараметрыЗапроса.Вставить("АутентификацияОС", Ложь);
	ПараметрыЗапроса.Вставить("Заголовки", Новый Соответствие);
	ПараметрыЗапроса.Вставить("ПутьДляСохранения");
	ПараметрыЗапроса.Вставить("ТипКонтента");
	ПараметрыЗапроса.Вставить("Кодировка", "utf-8");
	
	Если Параметры <> Неопределено Тогда
		ОбщегоНазначенияКлиентСервер.ДополнитьСтруктуру(ПараметрыЗапроса, Параметры, Истина);
	КонецЕсли;
	
	Возврат ПараметрыЗапроса;

КонецФункции

Функция УстановитьСоединение(URL, Параметры = Неопределено) Экспорт
	
	Если ТипЗнч(URL) = Тип("Строка") Тогда 
		СтруктураURI = ОбщегоНазначенияКлиентСервер.СтруктураURI(URL);
	Иначе
		СтруктураURI = ОбщегоНазначенияКлиентСервер.СтруктураURI("");
		ЗаполнитьЗначенияСвойств(СтруктураURI, URL);
	КонецЕсли;
	
	ПараметрыЗапроса = ПараметрыЗапроса(Параметры);
	
	Схема = ?(ЗначениеЗаполнено(СтруктураURI.Схема), СтруктураURI.Схема, "http");
	
	Прокси = ПараметрыЗапроса.Прокси;
	Если Прокси = Неопределено И ОбщегоНазначения.ПодсистемаСуществует("СтандартныеПодсистемы.ПолучениеФайловИзИнтернета") Тогда
		МодульПолучениеФайлов = ОбщегоНазначения.ОбщийМодуль("ПолучениеФайловИзИнтернетаКлиентСервер");
		Прокси = МодульПолучениеФайлов.ПолучитьПрокси(Схема);
	КонецЕсли;
	
	ЗащищенноеСоединение = ПараметрыЗапроса.ЗащищенноеСоединение;
	Если ПараметрыЗапроса.ЗащищенноеСоединение = Неопределено Тогда
		ЗащищенноеСоединение = ?(НРег(Схема) = "http", Неопределено, ОбщегоНазначенияКлиентСервер.НовоеЗащищенноеСоединение());
	КонецЕсли;
	
	Попытка
		Соединение = Новый HTTPСоединение(
			СтруктураURI.Хост,
			СтруктураURI.Порт,
			СтруктураURI.Логин,
			СтруктураURI.Пароль, 
			Прокси,
			ПараметрыЗапроса.Таймаут,
			ЗащищенноеСоединение,
			ПараметрыЗапроса.АутентификацияОС);
	Исключение
		HTTPСервисыСлужебный.ЗаписатьОшибкуВЖурналРегистрации(НСтр("ru = 'Установка соединения'"),
										 HTTPСервисыСлужебный.URIИзСтруктуры(СтруктураURI),
										 ПодробноеПредставлениеОшибки(ИнформацияОбОшибке()));
		ВызватьИсключение;
	КонецПопытки;
	
	Возврат Соединение;

КонецФункции

Функция ВыполнитьЗапрос(МетодHTTP = "GET", URL, Тело = "", Файл = "", Параметры = Неопределено, Перенаправления = Неопределено) Экспорт
	
	ПараметрыЗапроса = ПараметрыЗапроса(Параметры);
	
	Если ТипЗнч(URL) = Тип("Строка") Тогда 
		СтруктураURI = ОбщегоНазначенияКлиентСервер.СтруктураURI(URL);
	Иначе
		СтруктураURI = ОбщегоНазначенияКлиентСервер.СтруктураURI("");
		ЗаполнитьЗначенияСвойств(СтруктураURI, URL);
	КонецЕсли;
	
	Соединение = ПараметрыЗапроса.Соединение;
	Если ПараметрыЗапроса.Соединение = Неопределено Тогда
		Соединение = УстановитьСоединение(СтруктураURI, ПараметрыЗапроса);
	КонецЕсли;
	
	ЗапросHTTP = Новый HTTPЗапрос(СтруктураURI.ПутьНаСервере, ПараметрыЗапроса.Заголовки);
	ЗапросHTTP.Заголовки.Вставить("Accept-Charset", "utf-8");
	
	HTTPСервисыСлужебный.УстановитьТелоИЗаголовки(ЗапросHTTP, 
														Тело, 
														Файл, 
														ЗапросHTTP.Заголовки, 
														ПараметрыЗапроса.ТипКонтента, 
														ПараметрыЗапроса.Кодировка);

	Попытка
		ОтветHTTP = Соединение.ВызватьHTTPМетод(МетодHTTP, ЗапросHTTP, ПараметрыЗапроса.ПутьДляСохранения);
	Исключение
		HTTPСервисыСлужебный.ЗаписатьОшибкуВЖурналРегистрации(НСтр("ru = 'Выполнить запрос'"),
										 МетодHTTP,
										 HTTPСервисыСлужебный.URIИзСтруктуры(СтруктураURI) + Символы.ПС + 
										 ПодробноеПредставлениеОшибки(ИнформацияОбОшибке()));
		ВызватьИсключение;
	КонецПопытки;
	
	Если ОтветHTTP.КодСостояния = 301 		// 301 Moved Permanently
	 Или ОтветHTTP.КодСостояния = 302 		// 302 Found
	 Или ОтветHTTP.КодСостояния = 303 		// 303 See Other
	 Или ОтветHTTP.КодСостояния = 307 		// 307 Temporary Redirect
	 Или ОтветHTTP.КодСостояния = 308 Тогда // 308 Permanent Redirect
		
		Если Перенаправления = Неопределено Тогда
			Перенаправления = Новый Массив;
		КонецЕсли;
		
		Если Перенаправления.Количество() > 10 Тогда
			ВызватьИсключение НСтр("ru = 'Превышено количество перенаправлений: 10.'");
		Иначе 
			
			НовыйURL = ПолучитьЗаголовок(ОтветHTTP, "Location");
			
			Если НовыйURL = Неопределено Тогда 
				ВызватьИсключение НСтр("ru = 'Отсутствует заголовок ""Location"".'");
			КонецЕсли;
			
			НовыйURL = СокрЛП(НовыйURL);
			
			Если ПустаяСтрока(НовыйURL) Тогда
				ВызватьИсключение НСтр("ru = 'Пустой заголовок ""Location"".'");
			КонецЕсли;
			
			Если Перенаправления.Найти(НовыйURL) <> Неопределено Тогда
				ВызватьИсключение СтрШаблон(НСтр("ru = 'Циклическое перенаправление: %1'"), НовыйURL);
			КонецЕсли;
			
			Перенаправления.Добавить(HTTPСервисыСлужебный.URIИзСтруктуры(СтруктураURI));
			
			Если Не СтрНачинаетсяС(НовыйURL, "http") Тогда
				СтруктураURI.ПутьНаСервере = НовыйURL;
				НовыйURL = СтруктураURI;
			КонецЕсли;
			
			Если ОтветHTTP.КодСостояния = 303 Тогда // 303 See Other
				// В случае такого ответа, необходимо использовать метод GET
				МетодHTTP = "GET";
			КонецЕсли;
			
			Возврат ВыполнитьЗапрос(МетодHTTP, НовыйURL, Тело, Параметры, Перенаправления);

		КонецЕсли;
		
	КонецЕсли;
	
	Возврат ОтветHTTP;

КонецФункции

// Возвращает HTTPОтвет с двоичными данными файла
//
// Параметры:
//  URL	- Строка - URL расположения файла
//  ПараметрыОтправкиЗапроса - Структура - см. ПараметрыЗапроса
//  Перенаправления - Неопределено, Массив - массив перенапрвлений для исключения длинных цепочек и зацикливаний
// 
// Возвращаемое значение:
//  HTTPОтвет - полученный ответ
//
Функция ПолучитьДанныеФайлаПоURL(URL, ПараметрыОтправкиЗапроса, Перенаправления = Неопределено) Экспорт
	
	СтруктураURI = ОбщегоНазначенияКлиентСервер.СтруктураURI(URL);
	
	Соединение = УстановитьСоединение(URL, ПараметрыОтправкиЗапроса);	
	HTTPЗапрос = Новый HTTPЗапрос(СтруктураURI.ПутьНаСервере);
	ОтветHTTP = Соединение.Получить(HTTPЗапрос);
	
	Если ОтветHTTP.КодСостояния = 301 			// 301 Moved Permanently
		ИЛИ ОтветHTTP.КодСостояния = 302 		// 302 Found
		ИЛИ ОтветHTTP.КодСостояния = 303 		// 303 See Other
		ИЛИ ОтветHTTP.КодСостояния = 307 		// 307 Temporary Redirect
		ИЛИ ОтветHTTP.КодСостояния = 308 Тогда  // 308 Permanent Redirect
				
		Если Перенаправления = Неопределено Тогда
			Перенаправления = Новый Массив;
		КонецЕсли;
		
		Если Перенаправления.Количество() > 10 Тогда
			ВызватьИсключение НСтр("ru = 'Превышено количество перенаправлений: 10.'");
		Иначе 
			
			НовыйURL = ПолучитьЗаголовок(ОтветHTTP, "Location");
			
			Если НовыйURL = Неопределено Тогда 
				ВызватьИсключение НСтр("ru = 'Отсутствует заголовок ""Location"".'");
			КонецЕсли;
			
			Если Перенаправления.Найти(НовыйURL) <> Неопределено Тогда
				ВызватьИсключение СтрШаблон(НСтр("ru = 'Циклическое перенаправление: %1'"), НовыйURL);
			КонецЕсли;
			
			Перенаправления.Добавить(HTTPСервисыСлужебный.URIИзСтруктуры(СтруктураURI));
									
			Возврат ПолучитьДанныеФайлаПоURL(НовыйURL, ПараметрыОтправкиЗапроса, Перенаправления);
		КонецЕсли;
	КонецЕсли;
	
	Возврат ОтветHTTP;

КонецФункции

Функция РазобратьСоставноеТело(HTTPОбъект) Экспорт
	Возврат HTTPСервисыСлужебный.РазобратьСоставноеТело(HTTPОбъект);
КонецФункции

Функция ЗначениеИзТелаJSON(HTTPОбъект, ВСоответствие = Ложь) Экспорт
	
	Кодировка = Неопределено;
	
	ТипКонтента = ПолучитьЗаголовок(HTTPОбъект, "Content-Type");
	Если СтрНачинаетсяС(ТипКонтента, "application/json") Тогда
		ПозицияКодировки = СтрНайти(ТипКонтента, "charset=");
		Если ПозицияКодировки > 0 Тогда
			Кодировка = Сред(ТипКонтента, ПозицияКодировки + 8);
		КонецЕсли;
	КонецЕсли;
	
	Поток = HTTPОбъект.ПолучитьТелоКакПоток();
	
	Попытка
		Возврат ПрочитатьИзJSON(Поток,,, ВСоответствие, Кодировка);
	Исключение
	КонецПопытки;
	
	Попытка
		Возврат ПрочитатьИзJSON(Поток,,, ВСоответствие);
	Исключение
	КонецПопытки;
	
	Возврат Неопределено;
	
КонецФункции

// Разбирает строку URI на составные части и возвращает в виде структуры.
// На основе RFC 3986.
// Отличается от ОбщегоНазначенияКлиентСервер.СтруктураURI корректной обработкой логина:пароля в ссылке
//
// Параметры:
//     СтрокаURI - Строка - ссылка на ресурс в формате:
//                          <схема>://<логин>:<пароль>@<хост>:<порт>/<путь>?<параметры>#<якорь>.
//
// Возвращаемое значение:
//     Структура - составные части URI согласно формату:
//         * Схема         - Строка.
//         * Логин         - Строка.
//         * Пароль        - Строка.
//         * ИмяСервера    - Строка - часть <хост>:<порт> входного параметра.
//         * Хост          - Строка.
//         * Порт          - Строка.
//         * ПутьНаСервере - Строка - часть <путь>?<параметры>#<якорь> входного параметра.
//
Функция СтруктураURI(Знач СтрокаURI) Экспорт
	
	СтрокаURI = СокрЛП(СтрокаURI);
	
	// схема
	Схема = "";
	Позиция = СтрНайти(СтрокаURI, "://");
	Если Позиция > 0 Тогда
		Схема = НРег(Лев(СтрокаURI, Позиция - 1));
		СтрокаURI = Сред(СтрокаURI, Позиция + 3);
	КонецЕсли;

	СтрокаСоединения = СтрокаURI;
	
	// Информация пользователя и имя сервера.
	СтрокаАвторизации = "";
	Позиция = СтрНайти(СтрокаСоединения, "@");
	Если Позиция > 0 Тогда
		СтрокаАвторизации = Лев(СтрокаСоединения, Позиция - 1);
		СтрокаСоединения = Сред(СтрокаСоединения, Позиция + 1);
	КонецЕсли;
	
	// логин и пароль
	Логин = СтрокаАвторизации;
	Пароль = "";
	Позиция = СтрНайти(СтрокаАвторизации, ":");
	Если Позиция > 0 Тогда
		Логин = Лев(СтрокаАвторизации, Позиция - 1);
		Пароль = Сред(СтрокаАвторизации, Позиция + 1);
	КонецЕсли;
	
	// Строка соединения и путь на сервере.
	ПутьНаСервере = "";
	Позиция = СтрНайти(СтрокаСоединения, "/");
	Если Позиция > 0 Тогда
		ПутьНаСервере = Сред(СтрокаСоединения, Позиция + 1);
		ИмяСервера = Лев(СтрокаСоединения, Позиция - 1);
	КонецЕсли;
	
	// хост и порт
	Хост = ИмяСервера;
	Порт = "";
	Позиция = СтрНайти(ИмяСервера, ":");
	Если Позиция > 0 Тогда
		Хост = Лев(ИмяСервера, Позиция - 1);
		Порт = Сред(ИмяСервера, Позиция + 1);
		Если Не СтроковыеФункцииКлиентСервер.ТолькоЦифрыВСтроке(Порт) Тогда
			Порт = "";
		КонецЕсли;
	КонецЕсли;
	
	Результат = Новый Структура;
	Результат.Вставить("Схема", Схема);
	Результат.Вставить("Логин", Логин);
	Результат.Вставить("Пароль", Пароль);
	Результат.Вставить("ИмяСервера", ИмяСервера);
	Результат.Вставить("Хост", Хост);
	Результат.Вставить("Порт", ?(ПустаяСтрока(Порт), Неопределено, Число(Порт)));
	Результат.Вставить("ПутьНаСервере", ПутьНаСервере);
	
	Возврат Результат;
	
КонецФункции

Функция КодироватьКоллекциюВДанныеФормы(Коллекция, Разделитель = "&", ИмяПоляКлюч = "Ключ", ИмяПоляЗначение = "Значение", Кодировка = "utf-8") Экспорт
	
	Строка = Новый Массив;
	
	Для Каждого ЭлементКоллекции Из Коллекция Цикл
		
		Ключ = ЭлементКоллекции[ИмяПоляКлюч];
		Значение = ЭлементКоллекции[ИмяПоляЗначение];
		
		Если Значение <> Неопределено Тогда
			Строка.Добавить(СтрШаблон("%1=%2", Ключ, КодироватьСтроку(Значение, СпособКодированияСтроки.КодировкаURL, Кодировка)));
		Иначе
			Строка.Добавить(Ключ);
		КонецЕсли;
		
	КонецЦикла;
	
	Возврат СтрСоединить(Строка, Разделитель);
	
КонецФункции

Функция ПредставлениеОбъектаHTTP(HTTPОбъект) Экспорт
	Возврат HTTPСервисыСлужебный.ПредставлениеОбъектаHTTP(HTTPОбъект);
КонецФункции

Функция Base64ВКодировкеURL(Знач Данные = Неопределено) Экспорт

	Base64 = Base64Строка(Данные);
	Base64 = СтрРазделить(Base64, "=")[0];
	Base64 = СтрЗаменить(Base64, Символы.ВК + Символы.ПС, "");
	Base64 = СтрЗаменить(Base64, "+", "-");
	Base64 = СтрЗаменить(Base64, "/", "_");
	Возврат Base64;

КонецФункции

#КонецОбласти

#Область РаботаСФайлами

// Возвращает заголовки и тело ответа, сформированное из массива описаний файлов,
// подготовленных для отправки в составном теле
// 
// Параметры:
//  Файлы 		- Массив - Массив структур, в формате СтруктураОписаниеФайла()
//	ТипКонтента - Строка - Значение заголовка "Content-Type", без разделителя
//  Разделитель - Строка - Значение используемого разделителя (boundary)
//
// Возвращаемое значение:
//  Структура - со свойствами:
//    * Заголовки        - Соответствие   - Заголовки для подстановки в объект HTTP
//    * Тело             - ДвоичныеДанные - Двоичные данные для подстановки в тело
//
Функция ОбъединитьДанныеДляОтправки(МассивДанных, ТипКонтента = "multipart/form-data", Разделитель = "") Экспорт
	
	Если ПустаяСтрока(Разделитель) Тогда
		Разделитель = СтрЗаменить(Новый УникальныйИдентификатор, "-", "");
	КонецЕсли;
	
	ЗаголовокТипКонтента = СтрШаблон("%1; boundary=%2", ТипКонтента, Разделитель);
	
	Разделитель = "--" + СокрЛП(Разделитель);
	
	Заголовки = Новый Соответствие;
	Заголовки.Вставить("Connection", "keep-alive");
	Заголовки.Вставить("Content-Type", ЗаголовокТипКонтента);
	
	ТелоОтвета = Новый ПотокВПамяти;
	
	ЗаписьДанных = Новый ЗаписьДанных(ТелоОтвета);
	
	Для Каждого Данные Из МассивДанных Цикл
		
		ЧастьДанных = HTTPСервисыСлужебный.ЧастьСоставныхДанных(Данные);
		
		Если ЧастьДанных = Неопределено Тогда
			Продолжить;
		КонецЕсли;
		
		ЗаписьДанных.ЗаписатьСтроку(Разделитель);
		
		Если ТипКонтента = "multipart/form-data" Тогда
			Данные.Вставить("Расположение", "form-data");
		КонецЕсли;
		
		ЗаписьДанных.Записать(ЧастьДанных);
		
	КонецЦикла;
	
	ЗаписьДанных.ЗаписатьСтроку(Разделитель + "--");
	ЗаписьДанных.Закрыть();
	
	ДанныеТела = ТелоОтвета.ЗакрытьИПолучитьДвоичныеДанные();
	
	Результат = Новый Структура;
	Результат.Вставить("Заголовки", Заголовки);
	Результат.Вставить("Тело", ДанныеТела);
	
	Возврат Результат;
	
КонецФункции

// Возвращает структуру описания файла
//
// Параметры:
//  Расположение  	- Строка - Значение заголовка "Content-Disposition" без параметров
//							   inline - контент должен быть отображен внутри вэб-страницы или как вэб-страница
//							   attachment - указывает на скачиваемый контент; для инициирования диалога "Сохранить как"
//							   form-data для использования в качестве составной части multipart тела
//  Наименование  	- Строка - Значение параметра "name"
//	Данные 			- Строка, ДвоичныеДанные - Данные, отправляемые в теле ответа
//								Путь в файловой системе, адрес во временном хранилище или двоичные данные
//  ИмяФайла  		- Строка - Значение параметра "filename"
//  ТипКонтента  	- Строка - Значение заголовка "Content-Type"
//
// Возвращаемое значение:
//   Структура   - Описание файла вложения
//
Функция СтруктураОписаниеДанных(Расположение = "", Наименование = "", Данные = Неопределено, ИмяФайла = "", ТипКонтента = "") Экспорт
	
	ОписаниеДанных = Новый Структура;
	ОписаниеДанных.Вставить("Расположение", Расположение);
	ОписаниеДанных.Вставить("Наименование", Наименование);
	ОписаниеДанных.Вставить("Данные", 		Данные);
	ОписаниеДанных.Вставить("ИмяФайла", 	ИмяФайла);
	ОписаниеДанных.Вставить("ТипКонтента", 	ТипКонтента);
	
	Возврат ОписаниеДанных;
	
КонецФункции

// Возвращает структуру описания данных для формирования составного тела
//
// Параметры:
//  ПолноеИмяФайла 	- Строка - Полное имя файла в файловой системе доступной серверу
//  Расположение 	- Строка - заголовок "Content-Disposition"
//							   inline - контент должен быть отображен внутри вэб-страницы или как вэб-страница
//							   attachment - указывает на скачиваемый контент; для инициирования диалога "Сохранить как"
//							   form-data для использования в качестве составной части multipart тела
//  ТипКонтента 	- Строка - MIME-тип контента, если Неопределено - подбирается по расширению файла
//
// Возвращаемое значение:
//   Структура - Описание файла вложения, результат функции СтруктураОписаниеДанных
//
Функция СтруктураОписаниеДанныхПоИмениФайла(ПолноеИмяФайла, Расположение = "inline", ТипКонтента = Неопределено) Экспорт
	
	Файл = ОбщегоНазначенияКлиентСервер.РазложитьПолноеИмяФайла(ПолноеИмяФайла);
	
	Если ТипКонтента = Неопределено Тогда
		ТипКонтента = MIMEТипПоРасширению(Файл.Расширение);
	КонецЕсли;
	
	Возврат СтруктураОписаниеДанных(Расположение,
									Файл.ИмяБезРасширения,
									ПолноеИмяФайла,
									Файл.Имя,
									ТипКонтента);
	
КонецФункции

// Возвращает строку, содержащую MIME-тип, определенный по расширению
//
Функция MIMEТипПоРасширению(Расширение) Экспорт
	Возврат HTTPСервисыСлужебный.MIMEТипПоРасширению(Расширение);
КонецФункции

#КонецОбласти

#Область РаботаСДанными

// Возвращает значение из строки, содержащей текст JSON. JSON-текст должен быть корректным.
//
// Параметры:
//  ДанныеJSON  - Строка, Поток - строка, содержащая текст JSON.
//	ИменаСвойствДата - Массив, Строка, ФиксированныйМассив - Массив, элементы которого содержат имена свойств JSON, 
//															 для которых нужно вызывать восстановление даты из строки.
//  ФорматДаты  - ФорматДатыJSON - Определяет формат десериализации дат. По умолчанию ISO8601.
//  ВСоответствие  - Булево - Определяет чтение объекта JSON в Соответствие
//  Кодировка  - Строка, КодировкаТекста - Позволяет задать кодировку входного файла. Если передается, тогда ДанныеJSON
//                                         трактуются как путь к файлу.
//
// Возвращаемое значение:
//  Значение - Произвольное значение, извлеченное из JSON
//
Функция ПрочитатьИзJSON(Знач ДанныеJSON, Знач ИменаСвойствДата = Неопределено, Знач ФорматДаты = Неопределено, Знач ВСоответствие = Ложь, Знач Кодировка = Неопределено) Экспорт
	
	Если ПустаяСтрока(ДанныеJSON) Тогда
		Возврат Неопределено;
	КонецЕсли;
	
	Если ФорматДаты = Неопределено Тогда
		ФорматДаты = ФорматДатыJSON.ISO;
	КонецЕсли;
	
	Попытка		
		ЧтениеJSON = Новый ЧтениеJSON;
		Если ТипЗнч(ДанныеJSON) = Тип("Строка") И НЕ ЗначениеЗаполнено(Кодировка) Тогда
			ЧтениеJSON.УстановитьСтроку(ДанныеJSON);
		ИначеЕсли ТипЗнч(ДанныеJSON) = Тип("Строка") И ЗначениеЗаполнено(Кодировка) Тогда
			ЧтениеJSON.ОткрытьФайл(ДанныеJSON, Кодировка);
		ИначеЕсли ТипЗнч(ДанныеJSON) = Тип("Поток") ИЛИ 
				  ТипЗнч(ДанныеJSON) = Тип("ПотокВПамяти") ИЛИ 
				  ТипЗнч(ДанныеJSON) = Тип("ФайловыйПоток") Тогда
			ЧтениеJSON.ОткрытьПоток(ДанныеJSON, Кодировка);
		Иначе
			Возврат Неопределено;
		КонецЕсли;
		
		Значение = ПрочитатьJSON(ЧтениеJSON, ВСоответствие, ИменаСвойствДата, ФорматДаты);
		ЧтениеJSON.Закрыть();	
	Исключение
		ЗаписьЖурналаРегистрации("АРБИС.ПрочитатьИзJSON", 
								 УровеньЖурналаРегистрации.Ошибка,,
								 ДанныеJSON,
								 ПодробноеПредставлениеОшибки(ИнформацияОбОшибке()));
		ВызватьИсключение;
	КонецПопытки;
	
	Возврат Значение;
	
КонецФункции

// Возвращает значение в виде строки в формате JSON
// Формат даты по умолчанию ISO8601, символы переноса в формате Unix (если используются)
// Подробнее о допустимых типах значения в синтакс-помощнике ЗаписатьJSON
//
// Параметры:
//  Значение  - Произвольный - Значение, допустимое для преобразования в JSON.
//  Отступ  - Строка - Строка, добавляемая к каждой строке
//					   Общий сдвиг текста вправо, если требуется вывести форматирование для чтения человеком.
//  БезОтступов  - Булево - Если установлено в Истина, JSON сформируется без переносов и отступов.
//  ФорматДаты  - ФорматДатыJSON - Определяет формат сериализации дат
//
// Возвращаемое значение:
//  Строка - Строка в формате JSON
//
Функция ЗначениеВJSON(Знач Значение, Знач Отступ = "", Знач БезОтступов = Ложь, Знач ФорматДаты = Неопределено) Экспорт
	
	Если ФорматДаты = Неопределено Тогда
		ФорматДаты = ФорматДатыJSON.ISO;
	КонецЕсли;
	
	НастройкиСериализации = Новый НастройкиСериализацииJSON;
	НастройкиСериализации.ФорматСериализацииДаты = ФорматДаты;
	
	Если БезОтступов Тогда
		ПараметрыЗаписиJSON = Новый ПараметрыЗаписиJSON(ПереносСтрокJSON.Нет);
	Иначе
		ПараметрыЗаписиJSON = Новый ПараметрыЗаписиJSON(ПереносСтрокJSON.Unix, ?(Отступ = "", "", Символы.Таб));
	КонецЕсли;
	
	ДополнительныеПараметры = Новый Структура;
	ДополнительныеПараметры.Вставить("КэшЗначенийОбъектов", Новый Соответствие);
	
	ЗаписьJSON = Новый ЗаписьJSON;
	ЗаписьJSON.УстановитьСтроку(ПараметрыЗаписиJSON);
	
	ЗаписатьJSON(ЗаписьJSON, 
				 Значение, 
				 НастройкиСериализации, 
				 "ПреобразоватьДляJSON", 
				 HTTPСервисыСлужебный, 
				 ДополнительныеПараметры);
				 
	СтрокаJSON = ЗаписьJSON.Закрыть();
	
	Если СтрДлина(Отступ) > 1 Тогда
		МассивСтрок = СтрРазделить(СтрокаJSON, Символы.ПС, Истина);
		СтрокаJSON = СтрСоединить(МассивСтрок, СтрШаблон("%1%2", Символы.ПС, Отступ));
	КонецЕсли;
	
	Возврат СтрокаJSON;

КонецФункции

Функция UnixTimeStampВДату(UnixTimeStamp, ВремяВМиллисекундах = Ложь) Экспорт 
	
	Если НЕ ЗначениеЗаполнено(UnixTimeStamp) Тогда
		Возврат Неопределено;
	КонецЕсли;
	
	Если ВремяВМиллисекундах Тогда
		КоличествоСекунд = Цел(UnixTimeStamp / 1000);
	Иначе
		КоличествоСекунд = UnixTimeStamp;
	КонецЕсли;	
	
	Возврат Дата("19700101") + КоличествоСекунд;   
	
КонецФункции

#КонецОбласти

#КонецОбласти